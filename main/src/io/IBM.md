IBM: https://www.ibm.com/developerworks/cn/java/j-lo-javaio/

Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：

前两组主要是根据传输数据的数据格式:

基于字节操作的 I/O 接口：InputStream 和 OutputStream
基于字符操作的 I/O 接口：Writer 和 Reader


后两组主要是根据传输数据的方式:

基于磁盘操作的 I/O 接口：File
基于网络操作的 I/O 接口：Socket



不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？
这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。
我们知道字符到字节必须要经过编码转换，而这个编码又非常耗时，而且还会经常出现乱码问题


磁盘 I/O 工作机制
前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。
还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。
我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，
文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，
当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，
这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？
因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。
例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，
但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。
也就是使用这个电话记录要比打这个电话的次数多很多。何时真正会要检查一个文件存不存？
就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，
会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，
当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。
例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。


Java Socket 的工作机制
Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。
打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。
交通工具有多种，每种交通工具也有相应的交通规则。
Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。

数据传输
传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。
当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，
正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。
当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，
数据的写入和读取都是通过这个缓存区完成的。
写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，
如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。
值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，
由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，
如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。

